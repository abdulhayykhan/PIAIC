"""
5_live_cricket_scores.py

A small Streamlit app that fetches live cricket scores from the ESPN Cricinfo
RSS feed (https://static.cricinfo.com/rss/livescores.xml) using feedparser and
displays them in a clean, responsive UI with manual and optional auto refresh.

Usage:
    pip install streamlit feedparser
    streamlit run Assignments/5_live_cricket_scores.py

Requirements satisfied:
 - Single-file Streamlit app
 - Uses feedparser to parse RSS
 - Manual "Refresh Scores" button
 - Optional autorefresh via st_autorefresh
 - Graceful handling of network errors and empty feeds

Author: Generated by assistant (beginner-friendly, well-commented)
"""

from __future__ import annotations

import time
from typing import Any, Dict, List, Optional

import feedparser
import streamlit as st

# The RSS feed URL to parse
FEED_URL = "https://static.cricinfo.com/rss/livescores.xml"


@st.cache_data(ttl=60)
def fetch_scores(cache_bust: Optional[int] = None) -> Dict[str, Any]:
    """
    Fetch and parse the RSS feed.

    Args:
        cache_bust: optional int you can change to bust the cache (passed from UI)

    Returns:
        A dict with keys: 'entries' (list), 'feed_title' (str), 'updated' (float), 'error' (str|None)
    """
    try:
        # feedparser.parse returns a FeedParserDict
        feed = feedparser.parse(FEED_URL)

        # If something went wrong parsing the feed, feed.bozo may be True.
        if getattr(feed, "bozo", False):
            # feed.bozo_exception may hold an exception object
            exc = getattr(feed, "bozo_exception", None)
            msg = f"Failed to parse feed. {exc!s}" if exc else "Failed to parse feed." 
            return {"entries": [], "feed_title": "", "updated": time.time(), "error": msg}

        entries = []
        for entry in feed.entries:
            # Each entry commonly has title and summary (may include HTML)
            entries.append({
                "title": entry.get("title", "(No title)"),
                "summary": entry.get("summary", ""),
                "link": entry.get("link", ""),
            })

        return {"entries": entries, "feed_title": feed.feed.get("title", "Live Scores"), "updated": time.time(), "error": None}

    except Exception as e:
        # Catch network or unexpected errors and return friendly message
        return {"entries": [], "feed_title": "", "updated": time.time(), "error": f"Network or parsing error: {e}"}


def render_score_card(entry: Dict[str, str]) -> None:
    """
    Render a single match entry in a visually distinct container.

    We keep the layout simple and compatible with Streamlit's components so that
    beginners can read and modify it easily.
    """
    # Container makes each match block independent
    with st.container():
        st.markdown(f"**{entry['title']}**")
        # Summary may contain HTML; render as markdown allowing simple HTML
        st.markdown(entry["summary"], unsafe_allow_html=True)
        if entry.get("link"):
            st.markdown(f"[Match details]({entry['link']})")
        st.divider()


def main() -> None:
    st.set_page_config(page_title="Live Cricket Scores", page_icon="üèè", layout="wide")

    # Page header and short description
    st.title("Live Cricket Scores üèè")
    st.header("Powered by ESPN Cricinfo RSS feed")
    st.write(
        "This app fetches live cricket scores from the ESPN Cricinfo RSS feed and displays them in a clean, responsive layout."
    )

    # --- Controls ---
    col1, col2, col3 = st.columns([1, 1, 2])

    with col1:
        # Manual refresh button
        if st.button("Refresh Scores"):
            # When the button is clicked, set a session-state timestamp that will be
            # used as a cache-bust argument to `fetch_scores`. Streamlit automatically
            # reruns the script on interaction, so we don't need to call any
            # experimental rerun function (which may not exist in some versions).
            st.session_state["refresh_ts"] = int(time.time())

    with col2:
        # Autorefresh toggle and interval
        auto_refresh = st.checkbox("Auto-refresh every few minutes", value=True)

    with col3:
        interval_minutes = st.slider("Autorefresh interval (minutes)", min_value=1, max_value=30, value=2)

    # If autorefresh is enabled, inject a tiny client-side script that reloads the
    # browser window after the selected interval. This approach works across
    # Streamlit versions and avoids relying on `st_autorefresh` which may not be
    # available in older/newer versions.
    if auto_refresh:
        ms = interval_minutes * 60 * 1000
        # Use a namespaced timer on the window so switching intervals clears the
        # previous timer instead of stacking multiple reloads.
        reload_script = f"""
        <script>
        (function() {{
            try {{
                const ms = {ms};
                if (window.__streamlit_autorefresh_timer) {{
                    clearTimeout(window.__streamlit_autorefresh_timer);
                }}
                window.__streamlit_autorefresh_timer = setTimeout(function() {{
                    window.location.reload();
                }}, ms);
            }} catch (e) {{
                // ignore
            }}
        }})();
        </script>
        """

        st.markdown(reload_script, unsafe_allow_html=True)
        st.success(f"Auto-refresh enabled ‚Äî page will reload every {interval_minutes} minute(s).")

    # --- Fetch feed ---
    # Create a small cache_bust key so that manual refresh or autorefresh doesn't get stuck on cache.
    # If the user clicked the Refresh button, `st.session_state['refresh_ts']` will exist
    # and will change the cache key for `fetch_scores`, forcing a fresh network request.
    cache_bust = st.session_state.get("refresh_ts", int(time.time() // 10))
    result = fetch_scores(cache_bust)

    # --- Error handling ---
    if result.get("error"):
        st.error(result["error"])
        st.info("Try clicking 'Refresh Scores' or check your network connection.")
        return

    entries: List[Dict[str, str]] = result.get("entries", [])

    if not entries:
        st.info("No live matches found right now. Check again later.")
        return

    # Display feed metadata
    feed_title = result.get("feed_title", "Live Scores")
    updated_ts = result.get("updated", time.time())
    st.caption(f"Source: {feed_title} ‚Ä¢ Last fetched {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(updated_ts))}")

    # --- Display matches as responsive columns/cards ---
    # We'll show 2 cards per row on wide screens and 1 per row on narrow screens by using
    # Streamlit columns dynamically.
    cols_per_row = 2
    for i in range(0, len(entries), cols_per_row):
        row_entries = entries[i : i + cols_per_row]
        cols = st.columns(len(row_entries))
        for col, entry in zip(cols, row_entries):
            with col:
                st.markdown(f"### {entry['title']}")
                # Summary often contains small HTML fragments like <b> or <br> ‚Äî allow those
                st.markdown(entry["summary"], unsafe_allow_html=True)
                if entry.get("link"):
                    st.markdown(f"[Open details]({entry['link']})")

    # Helpful footer
    st.write("---")
    st.write("Tip: Use the 'Refresh Scores' button to manually get the latest feed instantly.")


if __name__ == "__main__":
    main()
